export default SubProcess;
export type StartDetector = (stdout: string, stderr?: string | undefined) => any;
export class SubProcess extends events<[never]> {
    /**
     * @param {string} cmd
     * @param {string[]} [args]
     * @param {any} [opts]
     */
    constructor(cmd: string, args?: string[] | undefined, opts?: any);
    /** @type {import('child_process').ChildProcess?} */
    proc: import("child_process").ChildProcess | null;
    /** @type {string[]} */
    args: string[];
    /**
     * @type {string}
     */
    cmd: string;
    /**
     * @type {any}
    */
    opts: any;
    /**
     * @type {boolean}
     */
    expectingExit: boolean;
    /**
     * @type {string}
     */
    rep: string;
    get isRunning(): boolean;
    /**
     *
     * @param {string} streamName
     * @param {Iterable<string>|string} lines
     */
    emitLines(streamName: string, lines: Iterable<string> | string): void;
    /**
     * spawn the subprocess and return control whenever we deem that it has fully
     * "started"
     *
     * @param {StartDetector|number?} startDetector
     * @param {number?} timeoutMs
     * @param {boolean} detach
     * @returns {Promise<void>}
     */
    start(startDetector?: StartDetector | (number | null), timeoutMs?: number | null, detach?: boolean): Promise<void>;
    /**
     * @deprecated This method is deprecated and will be removed
     */
    handleLastLines(): void;
    /**
     *
     * @param {NodeJS.Signals} signal
     * @param {number} timeout
     * @returns {Promise<void>}
     */
    stop(signal?: NodeJS.Signals, timeout?: number): Promise<void>;
    join(allowedExitCodes?: number[]): Promise<any>;
    detachProcess(): void;
    get pid(): number | null | undefined;
}
import events from 'events';
//# sourceMappingURL=subprocess.d.ts.map